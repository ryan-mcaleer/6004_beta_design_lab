.include "nominal.jsim"
.include "stdcell.jsim"

* Include your component files
.include "program_counter.jsim"
.include "register_file.jsim"
.include "control_logic.jsim"
.include "beta_helpers.jsim"
.include "alu.jsim"

.subckt beta clk reset ia[31:0] pc_plus4[31:0] id[31:0] ma[31:0]
+ moe mrd[31:0] wr mwd[31:0]

    * ========== INSTRUCTION FETCH ==========
    Xpc clk reset ia[31:0] pc_plus4[31:0] pc
    
    * ========== DECODE INSTRUCTION FIELDS ==========
    Xbuf_opcode id[31:26] opcode[5:0] buffer
    Xbuf_rc id[25:21] rc[4:0] buffer  
    Xbuf_ra id[20:16] ra[4:0] buffer
    Xbuf_rb id[15:11] rb[4:0] buffer
    Xbuf_lit id[15:0] literal[15:0] buffer
    
    * ========== CONTROL LOGIC ==========
    Xctl reset opcode[5:0] ra2sel bsel alufn[5:0] wdsel[1:0] werf moe wr ctl
    
    * ========== REGISTER FILE ==========
    Xregfile clk werf ra2sel ra[4:0] rb[4:0] rc[4:0]
    + wdata[31:0] radata[31:0] rbdata[31:0] regfile
    
    * ========== DATAPATH ==========
    
    * Sign-extend the 16-bit literal to 32 bits
    Xsext literal[15:0] sext_literal[31:0] signext16
    
    * BSEL mux: choose between rbdata (reg) or sign-extended literal
    * BSEL=0 -> rbdata, BSEL=1 -> sext_literal
    Xbsel_mux bsel rbdata[31:0] sext_literal[31:0] alu_b[31:0] mux2_32
    
    * ALU
    Xalu alufn[5:0] radata[31:0] alu_b[31:0] alu[31:0] z v n alu
    
    * ========== MEMORY INTERFACE ==========
    * Memory address = ALU output
    Xbufma alu[31:0] ma[31:0] buffer

    * Memory write data = rbdata
    * Memory write data = rbdata gated with wr
    XandMWD rbdata[0:31] wr#32 mwd[0:31] and2
    
    * ========== WRITE-BACK ==========    
    * WDSEL mux: choose data to write back to register
    * WDSEL=00 -> PC+4, WDSEL=01 -> ALU output, WDSEL=10 -> memory read data
    Xwdsel_mux wdsel[1:0] pc_plus4[31:0] alu[31:0] mrd[31:0] 0#32
    + wdata[31:0] mux4_32

.ends

.include "lab6basicblock.jsim"